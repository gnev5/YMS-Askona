# Задача YMS-1: Слот в календаре остается занятым после отмены бронирования

## Анализ проблемы

При отмене бронирования пользователем на странице "Мои бронирования", соответствующий временной слот в главном календаре продолжает отображаться как занятый. Это вынуждает пользователя обновлять страницу вручную, чтобы увидеть освободившийся слот.

### Причина ошибки

Ошибка вызвана комбинацией двух факторов: на бэкенде и на фронтенде.

**1. Основная причина (Бэкенд):**
Логика отмены бронирования на бэкенде является неполной. При вызове эндпоинта `PUT /api/bookings/{booking_id}/cancel`, функция `cancel_booking` в файле `backend/app/routers/bookings.py` только изменяет статус записи в таблице `bookings` с `confirmed` на `cancelled`.

**Она не удаляет связанные записи из таблицы `booking_time_slot`**.

Так как эти записи-связки продолжают существовать, при расчете доступности слотов для календаря, бэкенд по-прежнему считает эти слоты занятыми, даже если связанное бронирование отменено.

**2. Второстепенная причина (Фронтенд):**
На странице "Мои бронирования" (`pages/MyBookings.tsx`) функция `cancelBooking` после успешного запроса к API вызывает только `loadBookings()`. Эта функция обновляет только список бронирований для текущей страницы. Она не вызывает функцию `loadTimeSlots()`, которая отвечает за обновление данных для компонента календаря в `App.tsx`. В результате, даже если бы бэкенд работал корректно, календарь бы не обновился без перезагрузки страницы.

---

## План работ по исправлению

Исправление требует доработок как на бэкенде, так и на фронтенде для обеспечения корректной логики и плавной работы интерфейса.

### Часть 1: Исправление логики на Бэкенде (Критично)

1.  **Цель:** Модифицировать эндпоинт отмены бронирования так, чтобы он освобождал связанные временные слоты.
2.  **Файл для изменения:** `backend/app/routers/bookings.py`.
3.  **Задача:** Внутри функции `cancel_booking`, сразу после изменения статуса бронирования, необходимо добавить логику для удаления записей из таблицы `booking_time_slot`, где `booking_id` соответствует отменяемому бронированию.

    **Примерный код:**
    ```python
    # ... внутри def cancel_booking(...)
    
    # Существующая логика
    booking.status = "cancelled"
    booking.updated_at = datetime.utcnow()
    
    # ==> Добавить эту часть <==
    # Удаляем связи с временными слотами, чтобы они снова стали доступны
    db.query(models.BookingTimeSlot).filter(
        models.BookingTimeSlot.booking_id == booking_id
    ).delete()
    # ==> Конец добавляемой части <==
    
    db.commit()
    
    return {"message": "Booking cancelled successfully"}
    ```

### Часть 2: Улучшение UX на Фронтенде (Рекомендовано)

1.  **Цель:** Обеспечить автоматическое обновление календаря после отмены бронирования без необходимости перезагрузки страницы.
2.  **Файлы для изменения:** `frontend/src/App.tsx` и `frontend/src/pages/MyBookings.tsx`.
3.  **Задачи:**
    *   **В `App.tsx`:** Пробросить функцию `loadTimeSlots` в компонент `MyBookings` через новый пропс, например, `onBookingCancelled`.
        ```tsx
        // Внутри рендера App.tsx
        case 'my-bookings':
          return <MyBookings onBack={() => setPage('calendar')} onBookingCancelled={loadTimeSlots} />
        ```
    *   **В `MyBookings.tsx`:**
        *   Принять новый пропс `onBookingCancelled`.
        *   Вызвать `onBookingCancelled()` внутри функции `cancelBooking` после успешного выполнения API запроса.
        ```tsx
        // В MyBookings.tsx
        const MyBookings: React.FC<{ onBack: () => void; onBookingCancelled: () => void; }> = ({ onBack, onBookingCancelled }) => {
          // ...
          const cancelBooking = async (bookingId: number) => {
            if (window.confirm('Вы уверены, что хотите отменить эту запись?')) {
              try {
                // ... axios call
                await axios.put(...) 
                
                // Обновляем и список, и календарь
                loadBookings()
                onBookingCancelled() 
                
              } catch (error) {
                // ...
              }
            }
          }
          // ...
        }
        ```

Этот план обеспечит корректное освобождение слотов в базе данных и их мгновенное отображение на календаре, улучшая пользовательский опыт.
