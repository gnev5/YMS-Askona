# План развития и рекомендации по улучшению приложения YMS-Askona

Этот документ содержит результаты аудита приложения и представляет собой набор рекомендаций по улучшению его архитектуры, безопасности, дизайна и общей надежности.

---

## 1. Окружение и Управление Зависимостями

Текущая конфигурация проекта отлично подходит для разработки, но требует значительных доработок для развертывания в продуктивной среде.

### 1.1. Управление зависимостями

*   **Бэкенд (`requirements.txt`):** Зависимости в целом актуальны.
    *   **Рекомендация:** Для обеспечения 100% воспроизводимости окружения в будущем стоит внедрить инструменты вроде `pip-tools`. Это позволит зафиксировать не только прямые, но и вложенные зависимости с их хешами.
*   **Фронтенд (`package.json`):** Зависимости также актуальны.
    *   **Рекомендация (Важно):** Добавить инструменты для контроля качества кода.
        *   `eslint`: для поиска и исправления проблем в коде.
        *   `prettier`: для автоматического форматирования кода в едином стиле.
        *   `husky` и `lint-staged`: для автоматического запуска линтеров и форматтеров перед каждым коммитом. Это значительно повысит чистоту кодовой базы.

### 1.2. Docker и Конфигурация для Продакшена

Конфигурация в `docker-compose.yml` и связанные `Dockerfile` предназначены исключительно для разработки.

*   **Проблема:** Исходный код монтируется в контейнеры (`volumes`), а не копируется при сборке. Серверы запускаются в режиме отладки с автоперезагрузкой (`--reload`). Это небезопасно и неэффективно для продакшена.
*   **Проблема:** Секреты (учетные данные от БД) жестко прописаны в `docker-compose.yml`.
*   **Рекомендации:**
    1.  **Создать отдельные `Dockerfile.prod` для фронтенда и бэкенда.**
        *   **Бэкенд:** `Dockerfile.prod` не должен содержать опцию `--reload`.
        *   **Фронтенд:** `Dockerfile.prod` должен использовать многостадийную сборку (multi-stage build). На первом этапе собираются статичные файлы (`npm run build`), на втором — эти файлы помещаются в легковесный веб-сервер (например, `nginx`). Это уменьшит размер итогового образа в 5-10 раз и повысит безопасность.
    2.  **Создать отдельный файл `docker-compose.prod.yml`** для продуктивного развертывания, который будет использовать `Dockerfile.prod` и не будет монтировать исходный код.
    3.  **Безопасное управление секретами:** Убрать учетные данные из `docker-compose.yml`. В продуктивной среде их следует передавать через переменные окружения, предоставляемые средой выполнения (например, в CI/CD или облачном провайдере).

---

## 2. Аудит Бэкенда

Бэкенд написан на FastAPI и SQLAlchemy, что является современным и производительным стеком. Архитектура в целом хорошая, но есть важные точки для роста.

### 2.1. Безопасность

*   **Сильные стороны:** Механизм аутентификации на JWT-токенах и проверки ролей (`get_current_user`, `get_current_admin`) реализован грамотно и надежно.
*   **Рекомендации:**
    1.  **Открытый эндпоинт регистрации:** Сейчас любой желающий может создать пользователя через `POST /auth/register`. Если система не предполагает публичной регистрации, этот эндпоинт следует либо убрать, либо защитить правами администратора, как это сделано для `POST /auth/users`.
    2.  **Логирование:** Заменить отладочные `print()` на полноценную систему логирования (стандартный модуль `logging`). Это позволит гибко настраивать уровни логирования (INFO, DEBUG, ERROR) и отправлять логи в нужные места (консоль, файлы, внешние системы).

### 2.2. Структура и Бизнес-логика

*   **Сильные стороны:** Отличная структура моделей БД (`models.py`) с использованием SQLAlchemy 2.0.
*   **Рекомендации:**
    1.  **Выделение сервисного слоя:** Сложную бизнес-логику следует вынести из роутеров. Например, всю логику по поиску и валидации слотов в `routers/bookings.py::create_booking` стоит переместить в отдельную функцию или класс в "сервисном слое" (например, `services/booking_service.py`) или в модуль `crud.py`. Роутер должен отвечать только за прием запроса, валидацию базовых данных и вызов сервисной функции. Это улучшит читаемость и упростит тестирование.
    2.  **Явное управление транзакциями:** Сложные операции, изменяющие несколько таблиц (как создание брони), стоит оборачивать в явный блок `try...except...db.rollback()`, чтобы гарантировать атомарность операции.
    3.  **Упрощение логики статусов:** Рассмотреть возможность упрощения жизненного цикла бронирования. Возможно, статус `cancelled` избыточен, и можно сразу удалять бронь, или же настроить автоматическое удаление "отмененных" броней через некоторое время.

### 2.3. Автоматическое тестирование

*   **Проблема (Критично):** В проекте полностью отсутствуют автоматические тесты. Это самый серьезный недостаток бэкенда, который делает его развитие и поддержку крайне рискованными.
*   **Рекомендации:**
    1.  **Внедрить `pytest`:** Это стандарт де-факто для тестирования в Python.
    2.  **Настроить отдельную тестовую БД:** Тесты должны выполняться в изолированной базе данных, которая создается и наполняется перед запуском тестов и удаляется после.
    3.  **Написать тесты:** Начать следует с самых критичных частей:
        *   **Unit-тесты** для бизнес-логики (например, для функции поиска слотов, которую рекомендуется выделить в сервисный слой).
        *   **Интеграционные тесты** для API эндпоинтов: проверить логику создания пользователя, получения токена, создания и отмены бронирования, проверку прав доступа.
    4.  **Цель:** Достичь хотя бы 70-80% покрытия кода тестами (`code coverage`).

---

## 3. Аудит Фронтенда

Фронтенд написан на React и TypeScript с использованием Vite. Стек современный, но архитектура может быть значительно улучшена для упрощения дальнейшей разработки.

### 3.1. Архитектура и Управление состоянием

*   **Проблема:** Главная архитектурная проблема — ручное управление серверным состоянием через `axios` и `useState`. Это приводит к сложностям с синхронизацией данных между разными "страницами" (компонентами), как это было видно в задаче YMS-1.
*   **Рекомендация (Ключевая):** Внедрить библиотеку для управления серверным состоянием, например, **`React Query`** (TanStack Query) или `SWR`.
    *   **Преимущества:** Эти библиотеки автоматически управляют кешированием, инвалидацией кеша при мутациях (POST/PUT/DELETE запросах), отслеживают состояния загрузки и ошибок. Это кардинально упростит код, удалит необходимость в ручных `loadData()` и `useState` для серверных данных и решит проблемы с синхронизацией.
*   **Рекомендация:** Сложную логику по обработке и трансформации данных (например, группировку слотов в `CalendarView`) выносить из компонентов в кастомные хуки (`useCalendar.ts`) или функции-утилиты. Это сделает компоненты "глупее" и проще для понимания.

### 3.2. Дизайн и Пользовательский Опыт (UX)

*   **Проблема:** В проекте отсутствует единая дизайн-система. Стили написаны частично инлайн, частично классами без общей методологии.
*   **Рекомендации:**
    1.  **Внедрить UI-фреймворк:** Рассмотреть возможность использования готовой библиотеки компонентов, например, **Material-UI (MUI)**, **Ant Design** или **Mantine**. Это обеспечит консистентный и профессиональный внешний вид, а также предоставит готовые и доступные (accessibility) компоненты (модальные окна, кнопки, поля ввода).
    2.  **Улучшить обратную связь:** Добавить индикаторы загрузки на все асинхронные операции (например, в модальном окне бронирования при нажатии на кнопку "Забронировать") и использовать более наглядные уведомления об успехе/ошибке (например, всплывающие "тосты" вместо простого текста).

### 3.3. Автоматическое тестирование

*   **Проблема (Критично):** Тесты на фронтенде отсутствуют.
*   **Рекомендации:**
    1.  **Внедрить `Jest` и `React Testing Library`:** Это стандартный набор для тестирования React-приложений.
    2.  **Начать писать тесты:**
        *   **Unit-тесты** для утилит и кастомных хуков (например, для логики трансформации данных).
        *   **Компонентные тесты** для проверки рендеринга и взаимодействия с пользователем. Начать стоит с ключевых компонентов, таких как `BookingModal`, `Login`.

---

## 4. Общие рекомендации и DevOps

*   **Проблема:** Отсутствует автоматизация процессов проверки кода и развертывания.
*   **Рекомендации:**
    1.  **Настроить CI/CD (Continuous Integration / Continuous Deployment):** Использовать **GitHub Actions** для создания автоматизированного пайплайна.
    2.  **Шаги для CI-пайплайна (запуск на каждый push в main или pull request):**
        *   **Установка зависимостей** (бэкенд и фронтенд).
        *   **Проверка качества кода:** Запуск линтеров (`eslint` для фронтенда, `ruff` или `flake8` для бэкенда) и форматтеров (`prettier`, `black`).
        *   **Запуск автотестов** (бэкенд и фронтенд).
        *   **Сборка образов:** Убедиться, что `docker build` проходит успешно.
    3.  **Шаги для CD-пайплайна (запуск при слиянии в main, опционально):**
        *   Публикация `*.prod` образов в реестр контейнеров (например, Docker Hub, GitHub Container Registry).
        *   Автоматическое развертывание на сервере (например, через SSH и запуск `docker-compose -f docker-compose.prod.yml up -d`).

---
